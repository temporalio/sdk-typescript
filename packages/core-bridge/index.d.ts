import { SpanContext } from '@opentelemetry/api';
import { TLSConfig } from '@temporalio/internal-non-workflow-common';

export { TLSConfig };

export interface RetryOptions {
  /** Initial wait time before the first retry. */
  initialInterval: number;
  /**
   * Randomization jitter that is used as a multiplier for the current retry interval
   * and is added or subtracted from the interval length.
   */
  randomizationFactor: number;
  /** Rate at which retry time should be increased, until it reaches max_interval. */
  multiplier: number;
  /** Maximum amount of time to wait between retries. */
  maxInterval: number;
  /** Maximum total amount of time requests should be retried for, if None is set then no limit will be used. */
  maxElapsedTime?: number;
  /** Maximum number of retry attempts. */
  maxRetries: number;
}

export interface ClientOptions {
  /**
   * The URL of the Temporal server to connect to
   */
  url: string;

  /** Version string for the whole node SDK. Should never be set by user */
  sdkVersion: string;

  /**
   * TLS configuration options.
   *
   * Pass undefined to use a non-encrypted connection or an empty object to
   * connect with TLS without any customization.
   */
  tls?: TLSConfig;

  /**
   * Optional retry options for server requests.
   */
  retry?: RetryOptions;
}

/**
 * Log directly to console
 */
export interface ConsoleLogger {
  console: {};
}

/**
 * Forward logs to {@link Runtime} logger
 */
export interface ForwardLogger {
  forward: {
    /**
     * What level, if any, logs should be forwarded from core at
     *
     */
    // These strings should match the log::LevelFilter enum in rust
    level: LogLevel;
  };
}

/**
 * Logger types supported by Core
 */
export type Logger = ConsoleLogger | ForwardLogger;

/**
 * OpenTelemetry Collector options for exporting metrics or traces
 */
export interface OtelCollectorExporter {
  otel: {
    /**
     * URL of a gRPC OpenTelemetry collector.
     */
    url: string;
    /**
     * Optional set of HTTP request headers to send to Collector (e.g. for authentication)
     */
    headers?: Record<string, string>;
  };
}

/**
 * Prometheus metrics exporter options
 */
export interface PrometheusMetricsExporter {
  prometheus: {
    /**
     * Address to bind the Prometheus HTTP metrics exporter server
     * (for example, `0.0.0.0:1234`).
     *
     * Metrics will be available for scraping under the standard `/metrics` route.
     */
    bindAddress: string;
  };
}

/**
 * Metrics exporters supported by Core
 */
export type MetricsExporter = PrometheusMetricsExporter | OtelCollectorExporter;

/**
 * Trace exporters supported by Core
 */
export type TraceExporter = OtelCollectorExporter;

export interface TelemetryOptions {
  /**
   * A string in the env filter format specified here:
   * https://docs.rs/tracing-subscriber/0.2.20/tracing_subscriber/struct.EnvFilter.html
   *
   * Which determines what tracing data is collected in the Core SDK
   *
   * @default `temporal_sdk_core=WARN`
   */
  tracingFilter?: string;

  /**
   * If set true, do not prefix metrics with `temporal_`. Will be removed eventually as
   * the prefix is consistent with other SDKs.
   *
   * @default `false`
   */
  noTemporalPrefixForMetrics?: boolean;

  /**
   * Control where to send Rust Core logs
   *
   * @default log to console
   */
  logging?: Logger;

  /**
   * Control where to send traces generated by Rust Core, optional and turned off by default.
   *
   * This is typically used for profiling SDK internals.
   */
  tracing?: TraceExporter;

  /**
   * Control exporting {@link NativeConnection} and {@link Worker} metrics.
   *
   * Turned off by default
   */
  metrics?: MetricsExporter;
}

export interface WorkerOptions {
  /**
   * A human-readable string that can identify your worker
   */
  identity: string;
  /**
   * A string that should be unique to the exact worker code/binary being executed
   */
  buildId: string;

  /**
   * The task queue the worker will pull from
   */
  taskQueue: string;

  maxConcurrentActivityTaskExecutions: number;
  maxConcurrentWorkflowTaskExecutions: number;
  maxConcurrentLocalActivityExecutions: number;

  /**
   * If set to `false` this worker will only handle workflow tasks and local activities, it will not
   * poll for activity tasks.
   */
  enableNonLocalActivities: boolean;

  /**
   * How long a workflow task is allowed to sit on the sticky queue before it is timed out
   * and moved to the non-sticky queue where it may be picked up by any worker.
   */
  stickyQueueScheduleToStartTimeoutMs: number;

  /**
   * Maximum number of Workflow instances to cache before automatic eviction
   */
  maxCachedWorkflows: number;
  /**
   * Longest interval for throttling activity heartbeats
   * @default 60 seconds
   */
  maxHeartbeatThrottleIntervalMs: number;

  /**
   * Default interval for throttling activity heartbeats in case
   * `ActivityOptions.heartbeat_timeout` is unset.
   * When the timeout *is* set in the `ActivityOptions`, throttling is set to
   * `heartbeat_timeout * 0.8`.
   * @default 30 seconds
   */
  defaultHeartbeatThrottleIntervalMs: number;

  /**
   * Sets the maximum number of activities per second the task queue will dispatch, controlled
   * server-side. Note that this only takes effect upon an activity poll request. If multiple
   * workers on the same queue have different values set, they will thrash with the last poller
   * winning.
   */
  maxTaskQueueActivitiesPerSecond?: number;

  /**
   * Limits the number of activities per second that this worker will process. The worker will
   * not poll for new activities if by doing so it might receive and execute an activity which
   * would cause it to exceed this limit. Must be a positive floating point number.
   */
  maxActivitiesPerSecond?: number;
}

/** Log level - must match rust log level names */
export type LogLevel = 'TRACE' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';

export interface LogEntry {
  /** Log message */
  message: string;
  /**
   * Time since epoch [seconds, nanos].
   *
   * Should be switched to bigint once it is supported in neon.
   */
  timestamp: [number, number];
  /** Log level */
  level: LogLevel;
}

export interface Worker {}
export interface Runtime {}
export interface Client {}

export declare type PollCallback = (err: Error, result: ArrayBuffer) => void;
export declare type WorkerCallback = (err: Error, result: Worker) => void;
export declare type ClientCallback = (err: Error, result: Client) => void;
export declare type VoidCallback = (err: Error, result: void) => void;
export declare type LogsCallback = (err: Error, result: LogEntry[]) => void;

// TODO: improve type, for some reason Error is not accepted here
export declare function registerErrors(errors: Record<string, any>): void;
export declare function initTelemetry(telemOptions: TelemetryOptions): void;
export declare function newRuntime(): Runtime;
export declare function newClient(runtime: Runtime, clientOptions: ClientOptions, callback: ClientCallback): void;
export declare function newWorker(client: Client, workerOptions: WorkerOptions, callback: WorkerCallback): void;
export declare function newReplayWorker(
  runtime: Runtime,
  workerOptions: WorkerOptions,
  history: ArrayBuffer,
  callback: WorkerCallback
): void;
export declare function workerInitiateShutdown(worker: Worker, callback: VoidCallback): void;
export declare function workerFinalizeShutdown(worker: Worker): void;
export declare function clientUpdateHeaders(
  client: Client,
  headers: Record<string, string>,
  callback: VoidCallback
): void;
export declare function clientClose(client: Client): void;
export declare function runtimeShutdown(runtime: Runtime, callback: VoidCallback): void;
export declare function pollLogs(runtime: Runtime, callback: LogsCallback): void;
export declare function workerPollWorkflowActivation(
  worker: Worker,
  spanContext: SpanContext,
  callback: PollCallback
): void;
export declare function workerCompleteWorkflowActivation(
  worker: Worker,
  spanContext: SpanContext,
  result: ArrayBuffer,
  callback: VoidCallback
): void;
export declare function workerPollActivityTask(worker: Worker, spanContext: SpanContext, callback: PollCallback): void;
export declare function workerCompleteActivityTask(
  worker: Worker,
  spanContext: SpanContext,
  result: ArrayBuffer,
  callback: VoidCallback
): void;
export declare function workerRecordActivityHeartbeat(worker: Worker, heartbeat: ArrayBuffer): void;
export declare function getTimeOfDay(): [number, number];
